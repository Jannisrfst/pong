import turtle
import random
import time
import math

class AIBehavior:
    def move_paddle(self, paddle, ball):
        pass

class HardAI(AIBehavior):
    def move_paddle(self, paddle, ball):
        follow_probability = 0.25
        if random.random() < follow_probability:
            new_y = paddle.ycor() + 0.08 if ball.ycor() > paddle.ycor() else paddle.ycor() - 0.08 if ball.ycor() < paddle.ycor() else paddle.ycor()
            paddle.sety(new_y)

class MediumAI(AIBehavior):
    def move_paddle(self, paddle, ball):
        paddle.sety(max(-290, min(ball.ycor(), 290)))

class EasyAI(AIBehavior):
    def move_paddle(self, paddle, ball):
        target_y = paddle.ycor() + 0.2 if ball.ycor() > paddle.ycor() else paddle.ycor() - 0.2 if ball.ycor() < paddle.ycor() else paddle.ycor()
        paddle.sety(max(-290, min(target_y, 290)))

class Paddle(turtle.Turtle):
    def __init__(self, x, y):
        super().__init__()
        self.speed(0)
        self.shape("square")
        self.shapesize(stretch_wid=6, stretch_len=1)
        self.penup()
        self.color("white")
        self.goto(x, y)

class Ball(turtle.Turtle):
    def __init__(self):
        super().__init__()
        self.speed(0)
        self.shape("circle")
        self.penup()
        self.color("white")
        self.goto(0, 0)
        self.dx = 0.4
        self.dy = -0.4
        self.speed_level = 1

    def increase_speed(self):
        if self.speed_level < 3:
            self.speed_level += 1
            self.dx *= 1.05
            self.dy *= 1.05

def start_botpong_game(difficulty="medium"):
    window = turtle.Screen()
    window.title("Pong")
    window.setup(width=800, height=600)
    window.bgcolor("black")
    window.tracer(0)
    custom_font = ("Verdana", 18, "normal")

    paddle1 = Paddle(-350, 0)
    paddle2 = Paddle(350, 0)
    ball = Ball()

    ai_behavior = MediumAI() if difficulty == "1" else EasyAI() if difficulty == "2" else HardAI() if difficulty == "3" else MediumAI()

    score1 = 0
    score2 = 0

    scb = turtle.Turtle()
    scb.shape("square")
    scb.color("white")
    scb.penup()
    scb.hideturtle()
    scb.goto(0, 260)
    scb.write("Player 1: 0  Player 2: 0", align="center", font=custom_font)

    def paddle_up(paddle):
        paddle.sety(paddle.ycor() + 30)

    def paddle_down(paddle):
        paddle.sety(paddle.ycor() - 30)

    window.listen()
    window.onkeypress(lambda: paddle_up(paddle1), "w")
    window.onkeypress(lambda: paddle_down(paddle1), "s")
    window.onkeypress(lambda: paddle_up(paddle2), "Up")
    window.onkeypress(lambda: paddle_down(paddle2), "Down")

    while True:
        window.update()
        ball.setx(ball.xcor() + ball.dx)
        ball.sety(ball.ycor() + ball.dy)

        ai_behavior.move_paddle(paddle2, ball)

        if ball.ycor() > 290 or ball.ycor() < -290:
            ball.dy *= -1

        if (abs(ball.xcor() - paddle2.xcor()) < 10) and (paddle2.ycor() + 50 > ball.ycor() > paddle2.ycor() - 50):
            # Calculate the relative intersect y
            # This is the difference between the center of the paddle and the ball
            relative_intersect_y = (paddle2.ycor() + (50 / 2)) - ball.ycor()
            # Normalize the relative intersect y
            # This is the relative intersect y divided by half the height of the paddle
            normalized_relative_intersect_y = relative_intersect_y / (50 / 2)
            # Calculate the bounce angle
            # This is the normalized relative intersect y times the maximum angle of deflection
            bounce_angle = normalized_relative_intersect_y * (5 * math.pi / 12)
            # Update the ball's direction based on the bounce angle
            ball.dx = 0.4 * math.cos(bounce_angle)
            ball.dy = -0.4 * math.sin(bounce_angle)

        if (abs(ball.xcor() - paddle1.xcor()) < 10) and (paddle1.ycor() + 50 > ball.ycor() > paddle1.ycor() - 50):
            relative_intersect_y = (paddle1.ycor() + (50 / 2)) - ball.ycor()
            normalized_relative_intersect_y = relative_intersect_y / (50 / 2)
            bounce_angle = normalized_relative_intersect_y * (5 * math.pi / 12)
            ball.dx = -0.4 * math.cos(bounce_angle)
            ball.dy = -0.4 * math.sin(bounce_angle)

        if abs(ball.xcor()) > 390:
            ball.goto(0, 0)
            ball.dx *= -1
            score1 += 1 if ball.xcor() > 0 else 0
            score2 += 1 if ball.xcor() < 0 else 0
            scb.clear()
            scb.write(f"Player 1: {score1}  Player 2: {score2}", align="center", font=custom_font)
            
        if abs(ball.xcor()) < -390:
            ball.goto(0, 0)
            ball.dx *= -1
            score2 += 1
            scb.clear()
            scb.write(f"Player 1: {score1}  Player 2: {score2}", align="center", font=custom_font)

        ball.increase_speed()

if __name__ == "__main__":
    difficulty_level = input("Schwierigkeitsstufe w채hlen (3 f체r leicht, 2 f체r mittel, 1 f체r schwer): ")
    if difficulty_level not in ["1", "2", "3"]:
        print("2 Default.")
        difficulty_level = "1"
    start_botpong_game(difficulty_level)
